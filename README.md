# TasksCpp

## 1.2 step 4
Вам дана следующая иерархия классов:

struct Base { ... };

struct D1 : Base { ... };

struct D2 : Base { ... };

struct D3 : D1, D2 { ... };

Напишите функцию D1BaseToD2Basejj, которая преобразует указатель типа Base на объект типа D3, который ссылается на экземпляр Base, соответствующий D1, в указатель, ссылающийся на экземпляр Base соответствующий D2.
___

## 1.2 step 10
Предположим, что при разработке игры вам потребовался юнит "Челмедведосвин" (ManBearPig).
Завершите разработку иерархии классов и реализуйте необходимые конструкторы.
PS: В данном игровом контексте предполагается, что человек — не животное.
___

## 1.4 step 4
Вам требуется реализовать функцию, которая принимает на вход два указателя на базовый класс Expression, и возвращает true, если оба указателя указывают на самом деле на объекты одного и того же класса, и false в противном случае (т.е. если оба указателя указывают на BinaryOperation, то возвращается true, а если один из них указывает на Number, а второй на BinaryOperation, то false).

Реализуйте её при помощи typeid.

Требования к реализации: Использовать dynamic_cast и вызывать методы по переданным указателям запрещено.

___
## 1.4.7 step 7
Предположим, что вам даётся два указателя на объект некоторого сложного полиморфного класса, который использует множественное наследование. Оба указателя имеют один и тот же тип, но могут ссылаться на разные однотипные базы внутри одного объекта.

Напишите шаблонную функцию, которая по двум однотипным указателям проверяет, указывают ли они на один объект.
___

## 1.6 step 10
Напишите возвращающую bool шаблонную функцию compare, которая принимает
две константные ссылки на объекты одного типа и указатель на константный
метод этого типа без параметров, который в свою очередь возвращает значение
какого-то второго типа. Функция должна сравнивать объекты по значениям,
которые для них вернёт соответствующий метод, и возвращать true,
если значение для первого объекта оказалось меньше, чем для второго.
std::string s1("Elf");
std::string s2("Archer");
// сравнение строк по длине
bool r1 = compare(s1, s2, &std::string::size); // true
bool r2 = compare(s1, s1, &std::string::size); // false
___

## 2.1
 По аналогии с функцией printf с предыдущего степа напишите функцию print_values с переменным числом аргументов, которая для каждого аргумента выводит его тип и значение в поток std::ostream, который ей передан в качестве первого аргумента. Функция должна работать с произвольным числом аргументов.
Указание: для вывода имени типа нужно использовать std::type_info::name.
Например, вызов функции

print_values(std::cout, 0, 3.5, "Hello");

должен вывести на стандартный вывод примерно следующее (таким будет вывод на g++).

i: 0
d: 3.5
PKc: Hello
___

## 2.2
Дополните класс Array перемещающим конструктором и перемещающим оператором присваивания.

Замечание: все объявленные методы класса Array уже реализованы.
___

## 2.3 step 3
Напишите шаблонную функцию to_pair, которая принимает произвольный std::tuple и два индекса внутри и возвращает std::pair, содержащий элементы переданного std::tuple с соответствующими индексами.

Пример:

auto t = std::make_tuple(0, 3.5, "Hello");
std::pair<double, char const *> p = to_pair<1,2>(t);
// p содержит 3.5 и "Hello"
 
___
 2.3 step 5
 Напишите constexpr бинарные операторы +, - и * (скалярное произведение) для структуры Point.

Пример использования:

constexpr size_t size = static_cast<size_t>(Point(2,4) * Point(4,3));
int m[size]; // массив из 20 элементов */

// определение структуры Point уже подключено
___

2.3 step 11

Рассмотрим следующую функцию for_each.

Определите переменную square_fun, хранящую безымянную функцию, которая возводит переданное число в квадрат.

Пример:
int m[10] = {1,2,3,4,5,6,7,8,9,10};

for_each_int(m, m + 10, square_fun); // теперь m = {1,4,9,16,25,36,49,64,81,100};
___

2.3 step 13
*Рассмотрим следующую функцию find_if:

template<class F>
int * find_if(int * p, int * q, F f)
{
    for ( ; p != q; ++p )
        if (f(*p))
            return p;
    return q;
}

Определите переменную gen_finder, хранящую безымянную функцию, которая принимает массив значений типа int через два указателя и
возвращает безымянную функцию, которая в свою очередь принимает значение типа int и проверяет, есть ли это значение в переданном массиве.

Пример:

int primes[5] = {2,3,5,7,11};

int m[10] = {0,0,1,1,4,6,7,8,9,10};

// first_prime будет указывать на число 7
int * first_prime = find_if(m, m + 10, gen_finder(primes, primes + 5));
___

## 2.4

Напишите функцию apply, которая принимает некоторую функцию / функциональный объект, а так же аргументы для вызова этого объекта, и вызывает его, используя perfect forwarding.

Пример:

auto fun = [](std::string a, std::string const& b) { return a += b; };

std::string s("world!");

// s передаётся по lvalue ссылке,
// а временный объект по rvalue ссылке
s = apply(fun, std::string("Hello, "), s);

Примечание: гарантируется, что количество аргументов, переданных в apply, совпадает с количеством аргументов у функции/функционального объекта. При этом у функции может быть произвольное число аргументов.

Hint: ﻿в данном задании нужно использовать новый синтаксис определения функций.
___

## 3.2

Для последовательности s1,s2,s3,…,sn−1,sns1​,s2​,s3​,…,sn−1​,sn​ будем называть подотрезком подпоследовательность вида si,si+1,si+2,…,sj−2,sj−1si​,si+1​,si+2​,…,sj−2​,sj−1​ для некоторых ii и jj, i≤ji≤j, т.е. подотрезок — это непрерывная подпоследовательность.

Напишите функцию max_increasing_len, которая принимает последовательность, хранящуюся в std::list, по двум итераторам, и вычисляет для неё длину самого длинного строго возрастающего подотрезка.

Пример:

std::list<int> const l1 = {7,8,9,4,5,6,1,2,3,4};
size_t len1 = max_increasing_len(l1.begin(), l1.end()); // 4, соответствует подотрезку 1,2,3,4

std::list<int> const l2 = {-3,-2,-1,0,0,1,2,3,4,5};
size_t len2 = max_increasing_len(l2.begin(), l2.end()); // 6, соответствует подотрезку 0,1,2,3,4,5

Ограничения: не используйте другие контейнеры, не копируйте элементы из списка.

На первой неделе мы познакомились с RTTI и понятием мультиметодов. В этой задаче предлагается реализовать шаблонный класс Multimethod2, реализующий мультиметод от двух аргументов, который позволяет динамически добавлять новые реализации мультиметода для различных пар классов.

Вам нужно будет реализовать три метода класса Multimethod2:

    addImpl — добавляет реализацию мультиметода для двух типов, которые заданы через std::type_info.
    hasImpl — принимает два указателя и проверяет, есть ли реализация мультиметода для соответствующих типов.
    call — принимает два указателя и вызывает для них соответствующую реализацию.

Реализация этих методов должна корректно обрабатывать ситуацию, когда мультиметод является коммутативным (т.е. если результат вызова мультиметода не зависит от порядка аргументов).

Пример использования:

// базовый класс фигуры (полиморфный)
struct Shape { ... };

// прямоугольник
struct Rectangle : Shape { ... };

// треугольник
struct Triangle : Shape { ... };

// функция для проверки пересечения двух прямоугольников
bool is_intersect_r_r(Shape * a, Shape * b);

// функция для проверки пересечения прямоугольника и треугольника
bool is_intersect_r_t(Shape * a, Shape * b);


int main() 
{
    // мультиметод для наследников Shape
    // возращающий bool и являющийся коммутативным 
    Multimethod2<Shape, bool, true> is_intersect;

    // добавляем реализацию мультиметода для двух прямоугольников
    is_intersect.addImpl(typeid(Rectangle), typeid(Rectangle), is_intersect_r_r);

    // добавляем реализацию мультиметода для прямоугольника и треугольника
    is_intersect.addImpl(typeid(Rectangle), typeid(Triangle), is_intersect_r_t);

    // создаём две фигуры    
    Shape * s1 = new Triangle();
    Shape * s2 = new Rectangle();

    // проверяем, что реализация для s1 и s2 есть
    if (is_intersect.hasImpl(s1, s2))
    {
         // вызывается функция is_intersect_r_t(s2, s1)
         bool res = is_intersect.call(s1, s2);

         // Замечание: is_intersect_r_t ожидает,
         // что первым аргументом будет прямоугольник
         // а вторым треугольник, а здесь аргументы
         // передаются в обратном порядке. 
         // ваша реализация должна самостоятельно 
         // об этом позаботиться
    }
}
___


Для реализации вам потребуется положить std::type_info в какой-то контейнер. Однако по стандарту std::type_info нельзя копировать, поэтому просто так его в контейнер не положить. Для решения этой проблемы в новом стандарте появился специальный класс-обёртка std::type_index, который можно хранить в контейнерах и даже использовать в качестве ключа в упорядоченных ассоциативных контейнерах. std::type_index определён в заголовочном файле <typeindex>.

Дополнительную информацию вы найдёте в шаблоне кода.
